<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * 
 */

tm.app = tm.app || {};



(function() {
    
<span id='tm-app-CanvasElement'>    /**
</span>     * @class
     * キャンバスエレメント
     */
    tm.app.CanvasElement = tm.createClass({
        
        superClass: tm.app.Element,
        
        /**
         * 位置
<span id='tm-app-CanvasElement-property-position'>         */
</span>        position: null,
        /**
         * 回転
<span id='tm-app-CanvasElement-property-rotation'>         */
</span>        rotation: 0,
        /**
         * スケール
<span id='tm-app-CanvasElement-property-scale'>         */
</span>        scale: null,
        
        /**
         * 幅
         */
<span id='tm-app-CanvasElement-property-_width'>        _width:  64,
</span>        /**
         * 高さ
         */
<span id='tm-app-CanvasElement-property-_height'>        _height: 64,
</span>        
        /**
         * originX
         */
<span id='tm-app-CanvasElement-property-originX'>        originX: 0.5,
</span>        
        /**
         * originX
         */
<span id='tm-app-CanvasElement-property-originY'>        originY: 0.5,
</span>        
        /**
         * 更新フラグ
         */
<span id='tm-app-CanvasElement-property-isUpdate'>        isUpdate: true,
</span>        
        /**
         * 表示フラグ
         */
<span id='tm-app-CanvasElement-property-visible'>        visible: true,
</span>        
        /**
         * fillStyle
         */
<span id='tm-app-CanvasElement-property-fillStyle'>        fillStyle: &quot;white&quot;,
</span>        
        /**
         * strokeStyle
         */
<span id='tm-app-CanvasElement-property-strokeStyle'>        strokeStyle: &quot;white&quot;,
</span>        
        /**
         * アルファ
         */
        alpha: 1.0,
        
<span id='tm-app-CanvasElement-property-alpha'>        /**
</span>         * ブレンドモード
         */
        blendMode: &quot;source-over&quot;,
<span id='tm-app-CanvasElement-property-blendMode'>        
</span>        /**
         * シャドウカラー
         */
        shadowColor: &quot;black&quot;,
<span id='tm-app-CanvasElement-property-shadowColor'>        shadowOffsetX: 0,
</span>        shadowOffsetY: 0,
        shadowshadowBlur: 0,
        
        _matrix: null,
        
        /**
         * ゲーム用エレメントクラス
         */
        init: function() {
            this.superInit();
<span id='tm-app-CanvasElement-method-init'>            this.position = tm.geom.Vector2(0, 0);
</span>            this.scale    = tm.geom.Vector2(1, 1);
            this.pointing = tm.geom.Vector2(0, 0);
            this._matrix  = tm.geom.Matrix33();
            this._matrix.identity();
            this.eventFlags = {};
        },
        
        /**
         * 更新処理
         */
        update: function() {},
        /**
         * 描画処理
         */
<span id='tm-app-CanvasElement-method-update'>        draw: function(canvas) {},
</span>        
        drawBoundingCircle: function(canvas) {
<span id='tm-app-CanvasElement-method-draw'>            canvas.save();
</span>            canvas.lineWidth = 2;
            canvas.strokeCircle(0, 0, this.radius);
            canvas.restore();
        },
        
        drawBoundingRect: function(canvas) {
            canvas.save();
            canvas.lineWidth = 2;
            canvas.strokeRect(-this.width*this.originX, -this.height*this.originY, this.width, this.height);
            canvas.restore();
        },
        
        getFinalMatrix: function() {
            var matrix = tm.geom.Matrix33();

            if (this.parent) {
                matrix.multiply(this.parent.getFinalMatrix());
            }
            matrix.translate(this.centerX, this.centerY);
            matrix.rotateZ(this.rotation*Math.DEG_TO_RAD);
            matrix.scale(this.scaleX, this.scaleY);

            return matrix;
        },
        
        /**
         * 点と衝突しているかを判定
         */
        isHitPoint: function(x, y) {
            // 円判定
<span id='tm-app-CanvasElement-method-isHitPoint'>            var p = this.globalToLocal(tm.geom.Vector2(x, y));
</span>            this.pointing.x = p.x;
            this.pointing.y = p.y;
            
            if (((p.x)*(p.x)+(p.y)*(p.y)) &lt; (this.radius*this.radius)) {
                return true;
            }
            return false;
        },
        
        isHitPointRect: function(x, y) {
            // ここから下のバージョンは四角形
            var globalPos = (this.parent) ? this.parent.localToGlobal(this) : this;
            // var globalPos = this;
            
            var left   = globalPos.x - this.width*this.originX;
            var right  = globalPos.x + this.width*this.originX;
            var top    = globalPos.y - this.height*this.originY;
            var bottom = globalPos.y + this.height*this.originY;
            
            if ( left &lt; x &amp;&amp; x &lt; right &amp;&amp; top  &lt; y &amp;&amp; y &lt; bottom ) { return true; }
            
            return false;
        },
        
        /**
         * 階層を考慮した円衝突判定
         */
        isHitPointCircleHierarchy: function(x, y) {
            // 円判定
            var p = this.globalToLocal(tm.geom.Vector2(x, y));
<span id='tm-app-CanvasElement-method-isHitPointCircleHierarchy'>            this.pointing.x = p.x;
</span>            this.pointing.y = p.y;
            
            if (((p.x)*(p.x)+(p.y)*(p.y)) &lt; (this.radius*this.radius)) {
                return true;
            }
            return false;
        },
        
        /**
         * 階層を考慮した矩形衝突判定
         */
        isHitPointRectHierarchy: function(x, y) {
            var p = this.globalToLocal(tm.geom.Vector2(x, y));
            this.pointing.x = p.x;
            this.pointing.y = p.y;
<span id='tm-app-CanvasElement-method-isHitPointRectHierarchy'>            
</span>            var left   = -this.width*this.originX;
            var right  = +this.width*this.originX;
            var top    = -this.height*this.originY;
            var bottom = +this.height*this.originY;
            
            if ( left &lt; p.x &amp;&amp; p.x &lt; right &amp;&amp; top  &lt; p.y &amp;&amp; p.y &lt; bottom ) { return true; }
            
            return false;
        },
        
        /**
         * 要素と衝突しているかを判定
         */
        isHitElement: function(elm) {
            var selfGlobalPos  = this.parent.localToGlobal(this);
<span id='tm-app-CanvasElement-method-isHitElement'>            if (((this.x-elm.x)*(this.x-elm.x)+(this.y-elm.y)*(this.y-elm.y)) &lt; (this.radius+elm.radius)*(this.radius+elm.radius)) {
</span>                return true;
            }
            return false;
        },
        
        /**
         * ローカル座標をグローバル座標に変換
         */
        localToGlobal: function(p) {
            return this.getFinalMatrix().multiplyVector2(p);
        },
        
        /**
         * グローバル座標をローカル座標に変換
         */
        globalToLocal: function(p) {
<span id='tm-app-CanvasElement-method-localToGlobal'>            var matrix = this.getFinalMatrix();
</span>            matrix.invert();
            
            return matrix.multiplyVector2(p);
        },
        
        drawFillRect: function(ctx) {
<span id='tm-app-CanvasElement-method-globalToLocal'>            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
</span>            return this;
        },
        drawStrokeRect: function(ctx) {
            ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
            return this;
        },
        
        drawFillArc: function(ctx) {
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI*2, false);
            ctx.fill();
            ctx.closePath();
            return this;
        },
        drawStrokeArc: function(ctx) {
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI*2, false);
            ctx.stroke();
            ctx.closePath();
            return this;
        },
        
        wakeUp: function() {
            this.isUpdate = true;
            return this;
        },
        
        sleep: function() {
            this.isUpdate = false;
            return this;
        },
        
        show: function() {
            this.visible = true;
            return this;
        },
        
        hide: function() {
            this.visible = false;
            return this;
        },
        
        setX: function(x) {
            this.position.x = x;
            return this;
        },
        
        setY: function(y) {
            this.position.y = y;
            return this;
        },
        
        setPosition: function(x, y) {
            this.position.x = x;
            this.position.y = y;
            return this;
        },
        
        setWidth: function(width) {
            this.width = width;
            return this;
        },
        
        setHeight: function(height) {
            this.height = height;
            return this;
        },
        
        setSize: function(width, height) {
            this.width  = width;
            this.height = height;
            return this;
        },
        
        setFillStyle: function(style) {
            this.fillStyle = style;
            return this;
        },
        
        setStrokeStyle: function(style) {
            this.strokeStyle = style;
            return this;
        },
        
        fromJSON: function(data) {
            for (var key in data) {
                var value = data[key];
                if (key == &quot;children&quot;) {
                    for (var i=0,len=value.length; i&lt;len; ++i) {
                        var data = value[i];
                        var _class = window[data.type] || tm.app[data.type];
                        var elm = _class().addChildTo(this);
                        elm.fromJSON(data);
                        this[data.name] = elm;
                    }
                }
                else {
                    this[key] = value;
                }
            }
            
            return this;
        },
        
        toJSON: function() {
            // TODO:
        },
        
        _update: function(app) {
            // 更新有効チェック
            if (this.isUpdate == false) return ;
            
            this.update(app);
            
            var e = tm.event.Event(&quot;enterframe&quot;);
            e.app = app;
            this.dispatchEvent(e);
            
            // 子供達も実行
            if (this.children.length &gt; 0) {
                var tempChildren = this.children.slice();
                for (var i=0,len=tempChildren.length; i&lt;len; ++i) {
                    tempChildren[i]._update(app);
                }
                //this.execChildren(arguments.callee, app);
            }
        },
        
        _draw: function(canvas) {
            // 表示有効チェック
            if (this.visible === false) return ;
            
            var context = canvas.context;
            
            context.save();
            
            context.fillStyle      = this.fillStyle;
            context.strokeStyle    = this.strokeStyle;
            context.globalAlpha    *= this.alpha;
            context.globalCompositeOperation = this.blendMode;
            
            if (this.shadowBlur &gt; 0) {
                context.shadowColor     = this.shadowColor;
                context.shadowOffsetX   = this.shadowOffsetX;
                context.shadowOffsetY   = this.shadowOffsetY;
                context.shadowBlur      = this.shadowBlur;
            }
            
            // // 座標計算
            // var matrix = this.getFinalMatrix();
            // var m = matrix.m;
            // context.setTransform( m[0], m[1], m[3], m[4], m[6], m[7] );
            
            context.translate(this.position.x, this.position.y);
            context.rotate(this.rotation * Math.DEG_TO_RAD);
            context.scale(this.scale.x, this.scale.y);
            
            this.draw(canvas);
            
            // 子供達も実行
            if (this.children.length &gt; 0) {
                var tempChildren = this.children.slice();
                for (var i=0,len=tempChildren.length; i&lt;len; ++i) {
                    tempChildren[i]._draw(canvas);
                }
                // this.execChildren(arguments.callee, canvas);
            }
            
            context.restore();
            
            // // 衝突バウンディングボックス
            // canvas.strokeRect(this.left, this.top, this.width, this.height);
            // // 衝突バウンディングサークル
            // canvas.strokeCircle(this.x, this.y, this.radius);
        },
        
        
        _checkEvent: function(check_func, event_name) {
            
            if (check_func(this) === true) {
                this.eventFlags[event_name] = true;
                if (this[event_name]) this[event_name]();
            }
            else {
                this.eventFlags[event_name] = false;
            }
            
            for (var i=0; i&lt;this.children.length; ++i) {
                this.children[i]._checkEvent(check_func, event_name);
            }
        },
        
        _refreshSize: function() {},
        
        
    });
    
    
    /**
     * @property    x
     * x座標値
     */
    tm.app.CanvasElement.prototype.accessor(&quot;x&quot;, {
        &quot;get&quot;: function()   { return this.position.x; },
        &quot;set&quot;: function(v)  { this.position.x = v; }
    });
    
    /**
     * @property    y
     * y座標値
     */
    tm.app.CanvasElement.prototype.accessor(&quot;y&quot;, {
        &quot;get&quot;: function()   { return this.position.y; },
        &quot;set&quot;: function(v)  { this.position.y = v; }
    });
    
    /**
<span id='tm-app-CanvasElement-property-x'>     * @property    scaleX
</span>     * スケールX値
     */
    tm.app.CanvasElement.prototype.accessor(&quot;scaleX&quot;, {
        &quot;get&quot;: function()   { return this.scale.x; },
        &quot;set&quot;: function(v)  { this.scale.x = v; }
    });
    
    /**
<span id='tm-app-CanvasElement-property-y'>     * @property    scaleY
</span>     * スケールY値
     */
    tm.app.CanvasElement.prototype.accessor(&quot;scaleY&quot;, {
        &quot;get&quot;: function()   { return this.scale.y; },
        &quot;set&quot;: function(v)  { this.scale.y = v; }
    });
    
    
    
    /**
<span id='tm-app-CanvasElement-property-scaleX'>     * @property    width
</span>     * width
     */
    tm.app.CanvasElement.prototype.accessor(&quot;width&quot;, {
        &quot;get&quot;: function()   { return this._width; },
        &quot;set&quot;: function(v)  { this._width = v; this._refreshSize(); }
    });
    
<span id='tm-app-CanvasElement-property-scaleY'>    
</span>    /**
     * @property    height
     * height
     */
    tm.app.CanvasElement.prototype.accessor(&quot;height&quot;, {
        &quot;get&quot;: function()   { return this._height; },
        &quot;set&quot;: function(v)  { this._height = v; this._refreshSize(); }
    });
<span id='tm-app-CanvasElement-property-width'>    
</span>    /**
     * @property    radius
     * 半径
     */
    tm.app.CanvasElement.prototype.accessor(&quot;radius&quot;, {
        &quot;get&quot;: function()   { return this._radius || (this.width+this.height)/4; },
        &quot;set&quot;: function(v)  { this._radius = v; }
<span id='tm-app-CanvasElement-property-height'>    });
</span>    
    /**
     * @property    top
     * 左
     */
    tm.app.CanvasElement.prototype.getter(&quot;top&quot;, function() {
        return this.y - this.height*this.originY;
    });

    /**
     * @property    right
     * 左
     */
<span id='tm-app-CanvasElement-property-radius'>    tm.app.CanvasElement.prototype.getter(&quot;right&quot;, function() {
</span>        return this.x + this.width*(1-this.originX);
    });

    /**
     * @property    bottom
     * 左
     */
    tm.app.CanvasElement.prototype.getter(&quot;bottom&quot;, function() {
<span id='tm-app-CanvasElement-property-top'>        return this.y + this.height*(1-this.originY);
</span>    });

    /**
     * @property    left
     * 左
     */
    tm.app.CanvasElement.prototype.getter(&quot;left&quot;, function() {
<span id='tm-app-CanvasElement-property-right'>        return this.x - this.width*this.originX;
</span>    });

    /**
     * @property    centerX
     * centerX
     */
    tm.app.CanvasElement.prototype.accessor(&quot;centerX&quot;, {
<span id='tm-app-CanvasElement-property-bottom'>        &quot;get&quot;: function()   { return this.x + this.width/2 - this.width*this.originX; },
</span>        &quot;set&quot;: function(v)  {
            // TODO: どうしようかな??
        }
    });

    /**
     * @property    centerY
     * centerY
<span id='tm-app-CanvasElement-property-left'>     */
</span>    tm.app.CanvasElement.prototype.accessor(&quot;centerY&quot;, {
        &quot;get&quot;: function()   { return this.y + this.height/2 - this.height*this.originY; },
<span id='tm-app-CanvasElement-property-centerX'>        &quot;set&quot;: function(v)  {
</span>            // TODO: どうしようかな??
        }
    });
    
})();
</pre>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * canvas.js
 */

/*
 * 
 */
tm.graphics = tm.graphics || {};

(function() {
    
<span id='tm-graphics-Canvas'>    /**
</span>     * キャンバス
     */
    tm.graphics.Canvas = tm.createClass({
        
        /**
<span id='tm-graphics-Canvas-property-element'>         * 要素
</span>         */
        element: null,
        
        /**
<span id='tm-graphics-Canvas-property-canvas'>         * キャンバス
</span>         */
        canvas: null,
        
        /**
         * コンテキスト
<span id='tm-graphics-Canvas-property-context'>         */
</span>        context: null,
        
        /**
         * @constructor
<span id='tm-graphics-Canvas-method-constructor'>         * 初期化
</span>         */
        init: function(canvas) {
            this.canvas = null;
            if (typeof canvas == &quot;string&quot;) {
                this.canvas = document.querySelector(canvas);
            }
            else {
                this.canvas = canvas || document.createElement(&quot;canvas&quot;);
            }
            this.element            = this.canvas;
            this.context            = this.canvas.getContext(&quot;2d&quot;);
            this.context.lineCap    = &quot;round&quot;;
            this.context.lineJoin   = &quot;round&quot;;
        },
        
        /**
         * リサイズする
         */
<span id='tm-graphics-Canvas-method-resize'>        resize: function(width, height) {
</span>            this.canvas.width   = width;
            this.canvas.height  = height;
            return this;
        },
        
        /**
         * リサイズウィンドウ
         */
<span id='tm-graphics-Canvas-method-resizeWindow'>        resizeWindow: function() {
</span>            this.canvas.style.position  = &quot;fixed&quot;;
            this.canvas.style.margin    = &quot;0px&quot;;
            this.canvas.style.padding   = &quot;0px&quot;;
            this.canvas.style.left      = &quot;0px&quot;;
            this.canvas.style.top       = &quot;0px&quot;;
            return this.resize(window.innerWidth, window.innerHeight);
        },
        
        /**
         * フィット
         */
        resizeToFitScreen: function() {
<span id='tm-graphics-Canvas-method-resizeToFitScreen'>            this.canvas.style.position  = &quot;fixed&quot;;
</span>            this.canvas.style.margin    = &quot;0px&quot;;
            this.canvas.style.padding   = &quot;0px&quot;;
            this.canvas.style.left      = &quot;0px&quot;;
            this.canvas.style.top       = &quot;0px&quot;;
            return this.resize(window.innerWidth, window.innerHeight);
        },
        
        /**
         * 拡縮で画面にフィットさせる
         * 名前は仮. 検討する
         */
<span id='tm-graphics-Canvas-method-fitWindow'>        fitWindow: function(everFlag) {
</span>            var _fitFunc = function() {
                everFlag = everFlag === undefined ? true : everFlag;
                var e = this.element;
                var s = e.style;
                
                s.position = &quot;absolute&quot;;
                s.left = &quot;0px&quot;;
                s.top  = &quot;0px&quot;;
                
                var rateWidth = e.width/window.innerWidth;
                var rateHeight= e.height/window.innerHeight;
                var rate = e.height/e.width;
                
                if (rateWidth &gt; rateHeight) {
                    s.width  = innerWidth+&quot;px&quot;;
                    s.height = innerWidth*rate+&quot;px&quot;;
                }
                else {
                    s.width  = innerHeight/rate+&quot;px&quot;;
                    s.height = innerHeight+&quot;px&quot;;
                }
            }.bind(this);
            
            // 一度実行しておく
            _fitFunc();
            // リサイズ時のリスナとして登録しておく
            if (everFlag) {
                window.addEventListener(&quot;resize&quot;, _fitFunc, false);
            }
        },
        
        /**
         *  クリア
         */
        clear: function(x, y, width, height)
        {
            x = x || 0;
            y = y || 0;
<span id='tm-graphics-Canvas-method-clear'>            width = width || this.width;
</span>            height= height|| this.height;
            this.context.clearRect(x, y, width, height);
            return this;
        },
        
        
        /**
         * 色指定クリア
         * @param {String}  fillStyle
         * @param {Number}  [x=0]
         * @param {Number}  [y=0]
         * @param {Number}  [width=this.width]
<span id='tm-graphics-Canvas-method-clearColor'>         * @param {Number}  [height=this.height]
</span>         */
        clearColor: function(fillStyle, x, y, width, height)
        {
            x = x || 0;
            y = y || 0;
            width = width || this.width;
            height= height|| this.height;
            
            this.save();
            this.resetTransform();          // 行列初期化
            this.fillStyle = fillStyle;     // 塗りつぶしスタイルセット
            this.context.fillRect(x, y, width, height);
            this.restore();
            
            return this;
        },
                
        /**
         *  パスを開始(リセット)
         */
        beginPath: function()
        {
            this.context.beginPath();
            return this;
        },
                
        /**
         *  パスを閉じる
         */
<span id='tm-graphics-Canvas-method-beginPath'>        closePath: function()
</span>        {
            this.context.closePath();
            return this;
        },
        

        /**
         *  新規パス生成
         */
        moveTo: function(x, y)
        {
<span id='tm-graphics-Canvas-method-closePath'>            this.context.moveTo(x, y);
</span>            return this;
        },
        
        /**
         * パスに追加
         */
        lineTo: function(x, y)
        {
<span id='tm-graphics-Canvas-method-moveTo'>            this.context.lineTo(x, y);
</span>            return this;
        },
        
        /**
         * パス内を塗りつぶす
         */
        fill: function()
        {
<span id='tm-graphics-Canvas-method-lineTo'>            this.context.fill();
</span>            return this;
        },
        
        /**
         * パス上にラインを引く
         */
        stroke: function()
        {
            this.context.stroke();
<span id='tm-graphics-Canvas-method-fill'>            return this;
</span>        },
        
        /**
         * クリップ
         */
        clip: function()
        {
            this.context.clip();
            return this;
<span id='tm-graphics-Canvas-method-stroke'>        },
</span>        
        /**
         * 点描画
         */
        drawPoint: function(x, y)
        {
            return this.strokeRect(x, y, 1, 1);
<span id='tm-graphics-Canvas-method-clip'>            // return this.beginPath().moveTo(x-0.5, y-0.5).lineTo(x+0.5, y+0.5).stroke();
</span>        },

        /**
         * ラインパスを作成
         */
        line: function(x0, y0, x1, y1)
        {
<span id='tm-graphics-Canvas-method-drawPoint'>            return this.moveTo(x0, y0).lineTo(x1, y1);
</span>        },
        
        /**
         * ラインを描画
         */
        drawLine: function(x0, y0, x1, y1)
        {
            return this.beginPath().line(x0, y0, x1, y1).stroke();
<span id='tm-graphics-Canvas-method-line'>        },
</span>        
        /**
         * ダッシュラインを描画
         */
        drawDashLine: function(x0, y0, x1, y1, pattern)
        {
            var patternTable = null;
<span id='tm-graphics-Canvas-method-drawLine'>            if (typeof(pattern) == &quot;string&quot;) {
</span>                patternTable = pattern;
            }
            else {
                pattern = pattern || 0xf0f0;
                patternTable = pattern.toString(2);
<span id='tm-graphics-Canvas-method-drawDashLine'>            }
</span>            patternTable = patternTable.padding(16, '1');
            
            var vx = x1-x0;
            var vy = y1-y0;
            var len = Math.sqrt(vx*vx + vy*vy);
            vx/=len; vy/=len;
            
            var x = x0;
            var y = y0;
            for (var i=0; i&lt;len; ++i) {
                if (patternTable[i%16] == '1') {
                    this.drawPoint(x, y);
                    // this.fillRect(x, y, this.context.lineWidth, this.context.lineWidth);
                }
                x += vx;
                y += vy;
            }
            
            return this;
        },
        
        /**
         * v0(x0, y0), v1(x1, y1) から角度を求めて矢印を描画
         * http://hakuhin.jp/as/rotation.html
         */
        drawArrow: function(x0, y0, x1, y1, arrowRadius)
        {
            var vx = x1-x0;
            var vy = y1-y0;
            var angle = Math.atan2(vy, vx)*180/Math.PI;
            
            this.drawLine(x0, y0, x1, y1);
<span id='tm-graphics-Canvas-method-drawArrow'>            this.fillPolygon(x1, y1, arrowRadius || 5, 3, angle);
</span>            
            return this;
        },
        
        
        /**
         * lines
         */
        lines: function()
        {
            this.moveTo(arguments[0], arguments[1]);
            for (var i=1,len=arguments.length/2; i&lt;len; ++i) {
                this.lineTo(arguments[i*2], arguments[i*2+1]);
            }
            return this;
        },
        
        strokeLines: function()
        {
            this.beginPath();
<span id='tm-graphics-Canvas-method-lines'>            this.lines.apply(this, arguments);
</span>            this.stroke();
            return this;
        },
        
        fillLines: function()
        {
            this.beginPath();
            this.lines.apply(this, arguments);
            this.fill();
            return this;
        },
        
        /**
         * 四角形パスを作成する
         */
        rect: function(x, y, width, height)
        {
            this.context.rect.apply(this.context, arguments);
            return this;
        },
        
        /**
         * 四角形塗りつぶし描画
         */
        fillRect: function()
        {
            this.context.fillRect.apply(this.context, arguments);
            return this;
        },
        
<span id='tm-graphics-Canvas-method-rect'>        /**
</span>         * 四角形ライン描画
         */
        strokeRect: function()
        {
            this.context.strokeRect.apply(this.context, arguments);
            return this;
        },
        
        /**
         * 角丸四角形パス
<span id='tm-graphics-Canvas-method-fillRect'>         */
</span>        roundRect: function(x, y, width, height, radius) {
            var l = x + radius;
            var r = x + width - radius;
            var t = y + radius;
            var b = y + height - radius;
<span id='tm-graphics-Canvas-method-strokeRect'>            
</span>            /*
            var ctx = this.context;
            ctx.moveTo(l, y);
            ctx.lineTo(r, y);
            ctx.quadraticCurveTo(x+width, y, x+width, t);
            ctx.lineTo(x+width, b);
<span id='tm-graphics-Canvas-method-roundRect'>            ctx.quadraticCurveTo(x+width, y+height, r, y+height);
</span>            ctx.lineTo(l, y+height);
            ctx.quadraticCurveTo(x, y+height, x, b);
            ctx.lineTo(x, t);
            ctx.quadraticCurveTo(x, y, l, y);
            /**/
            
            this.context.arc(l, t, radius,     -Math.PI, -Math.PI*0.5, false);  // 左上
            this.context.arc(r, t, radius, -Math.PI*0.5,            0, false);  // 右上
            this.context.arc(r, b, radius,            0,  Math.PI*0.5, false);  // 右下
            this.context.arc(l, b, radius,  Math.PI*0.5,      Math.PI, false);  // 左下
            this.closePath();
            
            return this;
        },
        /**
         * 角丸四角形塗りつぶし
         */
        fillRoundRect: function(x, y, width, height, radius) {
            return this.beginPath().roundRect(x, y, width, height, radius).fill();
        },
        /**
         * 角丸四角形ストローク描画
         */
        strokeRoundRect: function(x, y, width, height, radius) {
            return this.beginPath().roundRect(x, y, width, height, radius).stroke();
        },
        
        /**
         * ポリゴンパス
         */
<span id='tm-graphics-Canvas-method-fillRoundRect'>        polygon: function(x, y, size, sides, offsetAngle) {
</span>            var radDiv = (Math.PI*2)/sides;
            var radOffset = (offsetAngle!=undefined) ? offsetAngle*Math.PI/180 : -Math.PI/2;
            
<span id='tm-graphics-Canvas-method-strokeRoundRect'>            this.moveTo(x + Math.cos(radOffset)*size, y + Math.sin(radOffset)*size);
</span>            for (var i=1; i&lt;sides; ++i) {
                var rad = radDiv*i+radOffset;
                this.lineTo(
                    x + Math.cos(rad)*size,
                    y + Math.sin(rad)*size
<span id='tm-graphics-Canvas-method-polygon'>                );
</span>            }
            this.closePath();
            return this;
        },
        /**
         * ポリゴン塗りつぶし
         */
        fillPolygon: function(x, y, radius, sides, offsetAngle) {
            return this.beginPath().polygon(x, y, radius, sides, offsetAngle).fill();
        },
        /**
         * ポリゴンストローク描画
         */
        strokePolygon: function(x, y, radius, sides, offsetAngle) {
            return this.beginPath().polygon(x, y, radius, sides, offsetAngle).stroke();
        },
        
        /**
         * star
         */
        star: function(x, y, radius, sides, sideIndent, offsetAngle) {
<span id='tm-graphics-Canvas-method-fillPolygon'>            var sideIndentRadius = radius * (sideIndent || 0.38);
</span>            var radOffset = (offsetAngle) ? offsetAngle*Math.PI/180 : -Math.PI/2;
            var radDiv = (Math.PI*2)/sides/2;
            
            this.moveTo(
<span id='tm-graphics-Canvas-method-strokePolygon'>                x + Math.cos(radOffset)*radius,
</span>                y + Math.sin(radOffset)*radius
            );
            for (var i=1; i&lt;sides*2; ++i) {
                var rad = radDiv*i + radOffset;
<span id='tm-graphics-Canvas-method-star'>                var len = (i%2) ? sideIndentRadius : radius;
</span>                this.lineTo(
                    x + Math.cos(rad)*len,
                    y + Math.sin(rad)*len
                );
            }
            this.closePath();
            return this;
        },
        
        fillStar: function(x, y, radius, sides, sideIndent, offsetAngle) {
            return this.beginPath().star(x, y, radius, sides, sideIndent, offsetAngle).fill();
        },
        strokeStar: function(x, y, radius, sides, sideIndent, offsetAngle) {
            return this.beginPath().star(x, y, radius, sides, sideIndent, offsetAngle).stroke();
        },

        /*
         * heart
         */
        heart: function(x, y, radius, angle) {
            var half_radius = radius*0.5;
            var rad = (angle === undefined) ? Math.PI/4 : Math.degToRad(angle);

            // 半径 half_radius の角度 angle 上の点との接線を求める
            var p = Math.cos(rad)*half_radius;
            var q = Math.sin(rad)*half_radius;

            // 円の接線の方程式 px + qy = r^2 より y = (r^2-px)/q
            var x2 = -half_radius;
            var y2 = (half_radius*half_radius-p*x2)/q;

            // 中心位置調整
            var height = y2 + half_radius;
            var offsetY = half_radius-height/2;

            // パスをセット
            this.moveTo(0+x, y2+y+offsetY);

            this.arc(-half_radius+x, 0+y+offsetY, half_radius, Math.PI-rad, Math.PI*2);
            this.arc(half_radius+x, 0+y+offsetY, half_radius, Math.PI, rad);
            this.closePath();

            return this;
        },

        /*
         * fill heart
         */
        fillHeart: function(x, y, radius, angle) {
            return this.beginPath().heart(x, y, radius, angle).fill();
        },

        /*
         * stroke heart
         */
        strokeHeart: function(x, y, radius, angle) {
            return this.beginPath().heart(x, y, radius, angle).stroke();
        },
        
        /**
         * 円のパスを設定
         */
        circle: function(x, y, radius)
        {
            this.context.arc(x, y, radius, 0, Math.PI*2, false);
            return this;
        },
        
        /**
         * 塗りつぶし円を描画
         */
        fillCircle: function(x, y, radius)
        {
            var c = this.context;
            c.beginPath();
            c.arc(x, y, radius, 0, Math.PI*2, false);
            c.closePath();
            c.fill();
            return this;
            // return this.beginPath().circle(x, y, radius).fill();
        },
        
        /**
         * ストローク円を描画
         */
        strokeCircle: function(x, y, radius)
<span id='tm-graphics-Canvas-method-circle'>        {
</span>            return this.beginPath().circle(x, y, radius).stroke();
        },
        
        
        /**
         * 円弧のパスを設定
         */
<span id='tm-graphics-Canvas-method-fillCircle'>        arc: function(x, y, radius, startAngle, endAngle, anticlockwise)
</span>        {
            this.context.arc(x, y, radius, startAngle, endAngle, anticlockwise);
            return this;
        },
        
        /**
         * 塗りつぶし円弧を描画
         */
        fillArc: function(x, y, radius, startAngle, endAngle, anticlockwise)
        {
            return this.beginPath().arc(x, y, radius, startAngle, endAngle, anticlockwise).fill();
        },
        
<span id='tm-graphics-Canvas-method-strokeCircle'>        /**
</span>         * ストローク円弧を描画
         */
        strokeArc: function(x, y, radius, startAngle, endAngle, anticlockwise)
        {
<span id='tm-graphics-Canvas-method-arc'>            return this.beginPath().arc(x, y, radius, startAngle, endAngle, anticlockwise).stroke();
</span>        },
        
        /**
         * 三角形パスを設定
         */
        triangle: function(x0, y0, x1, y1, x2, y2)
        {
            this.moveTo(x0, y0).lineTo(x1, y1).lineTo(x2, y2);
            this.closePath();
            return this;
<span id='tm-graphics-Canvas-method-fillArc'>        },
</span>        
        /**
         * 塗りつぶし三角形を描画
         */
        fillTriangle: function(x0, y0, x1, y1, x2, y2)
        {
            return this.beginPath().triangle(x0, y0, x1, y1, x2, y2).fill();
        },
        
        /**
         * ストローク三角形を描画
         */
<span id='tm-graphics-Canvas-method-strokeArc'>        strokeTriangle: function(x0, y0, x1, y1, x2, y2)
</span>        {
            return this.beginPath().triangle(x0, y0, x1, y1, x2, y2).stroke();
        },
        

        /**
         * 塗りつぶしテキストを描画
         */
        fillText: function(text, x, y)
        {
<span id='tm-graphics-Canvas-method-triangle'>            return this.context.fillText.apply(this.context, arguments);
</span>        },
        
        /**
         * ストロークテキスト
         */
        strokeText: function(text, x, y)
        {
            return this.context.strokeText.apply(this.context, arguments);
<span id='tm-graphics-Canvas-method-fillTriangle'>        },
</span>        
        /**
         * 塗りつぶしテキスト
         */
        fillTextList: function(text_list, x, y, offsetX, offsetY)
        {
            offsetX = offsetX || 0;
            offsetY = offsetY || 20;
            
<span id='tm-graphics-Canvas-method-strokeTriangle'>            for (var i=0,len=text_list.length; i&lt;len; ++i) {
</span>                this.fillText(text_list[i], x+offsetX*i, y+offsetY*i);
            }
            
            return this;
        },
        
        /**
         * ストロークテキストリスト
<span id='tm-graphics-Canvas-method-fillText'>         */
</span>        strokeTextList: function(text_list, x, y, offsetX, offsetY)
        {
            offsetX = offsetX || 0;
            offsetY = offsetY || 20;
            
<span id='tm-graphics-Canvas-method-strokeText'>            for (var i=0,len=text_list.length; i&lt;len; ++i) {
</span>                this.strokeText(x+offsetX*i, y+offsetY*i, text_list[i]);
            }
            
            return this;
        },
                
        /**
         * 画像描画
         */
<span id='tm-graphics-Canvas-method-fillTextList'>        drawImage: function(image, x, y)
</span>        {
            this.context.drawImage.apply(this.context, arguments);
            return ;
            
            x = x || 0;
            y = y || 0;
            this.context.drawImage(image, x, y);
            return this;
            // ctx.drawImage(this.image.canvas,
                // 0, 0, this.width, this.height,
<span id='tm-graphics-Canvas-method-strokeTextList'>                // -this.width/2, -this.height/2, this.width, this.height);
</span>        },
        
        /**
         * テクスチャ描画
         */
        drawTexture: function(texture, x, y)
        {
            arguments[0] = texture.element;
            this.context.drawImage.apply(this.context, arguments);
            
            return ;
        },
        
        /**
         * ビットマップ描画
         */
        drawBitmap: function(bitmap, x, y)
        {
            arguments[0] = bitmap.imageData;
<span id='tm-graphics-Canvas-method-drawImage'>            this.context.putImageData.apply(this.context, arguments);
</span>            
            return ;
        },
        
        /**
         * 行列をセット
         */
        setTransform: function(m11, m12, m21, m22, dx, dy)
        {
            this.context.setTransform(m11, m12, m21, m22, dx, dy);
            return this;
        },
        
        
        /**
         * 行列をリセット
         */
        resetTransform: function()
        {
            this.setTransform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
<span id='tm-graphics-Canvas-method-drawTexture'>            return this;
</span>        },
        
        
        /**
         * 中心に移動
         */
        setTransformCenter: function()
        {
            this.context.setTransform(1, 0, 0, 1, this.width/2, this.height/2);
            return this;
        },
        
        /**
<span id='tm-graphics-Canvas-method-drawBitmap'>         * 行列を掛ける
</span>         */
        transform: function(m11, m12, m21, m22, dx, dy)
        {
            this.context.transform(m11, m12, m21, m22, dx, dy);
            return this;
        },
        
        /**
         * 保存
         */
        save: function()
        {
<span id='tm-graphics-Canvas-method-setTransform'>            this.context.save();
</span>            return this;
        },
        
        /**
         * 復元
         */
        restore: function()
        {
            this.context.restore();
            return this;
        },
        
        /**
         * 移動
<span id='tm-graphics-Canvas-method-resetTransform'>         */
</span>        translate: function(x, y)
        {
            this.context.translate(x, y);
            return this;
        },
        
        /**
         * 回転
         */
        rotate: function(rotation)
<span id='tm-graphics-Canvas-method-setTransformCenter'>        {
</span>            this.context.rotate(rotation);
            return this;
        },
        
        /**
         * スケール
         */
        scale: function(scaleX, scaleY)
        {
<span id='tm-graphics-Canvas-method-transform'>            this.context.scale(scaleX, scaleY);
</span>            return this;
        },
        
        /**
         * 画像として保存
         */
        saveAsImage: function(mime_type) {
            mime_type = mime_type || tm.graphics.Canvas.MIME_TYPE_PNG;
<span id='tm-graphics-Canvas-method-save'>            var data_url = this.canvas.toDataURL(mime_type);
</span>            // data_url = data_url.replace(mime_type, &quot;image/octet-stream&quot;);
<span id='tm-graphics-Canvas-method-restore'>            window.open(data_url, &quot;save&quot;);
</span>            
            // toDataURL を使えば下記のようなツールが作れるかも!!
            // TODO: プログラムで絵をかいて保存できるツール
        },
        
<span id='tm-graphics-Canvas-method-translate'>        setCompositing: function(alpha, compositeOperation)
</span>        {
            // TODO
        },
        
        setFillStyle: function(style)
        {
            this.context.fillStyle = style;
<span id='tm-graphics-Canvas-method-rotate'>            return this;
</span>        },
        
        setStrokeStyle: function(style)
        {
            this.context.strokeStyle = style;
            return this;
        },
<span id='tm-graphics-Canvas-method-scale'>        
</span>        /**
         * 
<span id='tm-graphics-Canvas-method-saveAsImage'>         * @see &lt;a href=&quot;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#colors-and-styles&quot;&gt;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#colors-and-styles&lt;/a&gt;
</span>         */
        setColorStyle: function(stroke, fill)
        {
            fill = fill || stroke;
            
            this.context.strokeStyle    = stroke;
            this.context.fillStyle      = fill;
            return this;
        },
        
        /**
         * テキストをセット
         */
        setText: function(font, align, baseline)
        {
            var c = this.context;
            c.font          = font;
            c.textAlign     = align;
            c.textBaseline  = baseline;
        },
        
        /**
         * ラインスタイルを一括セット
         * @see &lt;a href=&quot;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#line-styles&quot;&gt;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#line-styles&lt;/a&gt;
         */
        setLineStyle: function(width, cap, join, miter) {
            with(this.context) {
                lineWidth   = width || 1;
                lineCap     = cap   || &quot;round&quot;;
<span id='tm-graphics-Canvas-method-setColorStyle'>                lineJoin    = join  || &quot;round&quot;;
</span>                miterLimit  = miter || 10.0;
            }
            return this;
        },
        
        /**
         * 影をセット
         * - &lt;http://www.html5.jp/canvas/ref/property/shadowColor.html&gt;
         * - &lt;http://www.w3.org/TR/2010/WD-2dcontext-20100624/#shadows&gt;
         */
        setShadow: function(color, offsetX, offsetY, blur) {
            var ctx = this.context;
            
<span id='tm-graphics-Canvas-method-setText'>            ctx.shadowColor     = color     || &quot;black&quot;;
</span>            ctx.shadowOffsetX   = offsetX   || 0;
            ctx.shadowOffsetY   = offsetY   || 0;
            ctx.shadowBlur      = blur      || 0;
            
            return this;
        },
        
        getElement: function() {
<span id='tm-graphics-Canvas-method-setLineStyle'>            return this.element;
</span>        },
        
    });
    
    tm.graphics.Canvas.MIME_TYPE_PNG = &quot;image/png&quot;;
    tm.graphics.Canvas.MIME_TYPE_JPG = &quot;image/jpeg&quot;;
    tm.graphics.Canvas.MIME_TYPE_SVG = &quot;image/svg+xml&quot;;
    
    /**
     * @property    width
     * 幅
     */
    tm.graphics.Canvas.prototype.accessor(&quot;width&quot;, {
        &quot;get&quot;: function()   { return this.canvas.width; },
        &quot;set&quot;: function(v)  { this.canvas.width = v; }
    });
    
    /**
     * @property    height
     * 高さ
     */
    tm.graphics.Canvas.prototype.accessor(&quot;height&quot;, {
<span id='tm-graphics-Canvas-method-setShadow'>        &quot;get&quot;: function()   { return this.canvas.height; },
</span>        &quot;set&quot;: function(v)  { this.canvas.height = v;   }
    });
    
    /**
     * @property    fillStyle
     * 塗りつぶしスタイル
     */
    tm.graphics.Canvas.prototype.accessor(&quot;fillStyle&quot;, {
        &quot;get&quot;: function()   { return this.context.fillStyle; },
        &quot;set&quot;: function(v)  { this.context.fillStyle = v;   }
    });
    
    
    /**
     * @property    strokeStyle
     * ストロークスタイル
     */
    tm.graphics.Canvas.prototype.accessor(&quot;strokeStyle&quot;, {
        &quot;get&quot;: function()   { return this.context.strokeStyle; },
        &quot;set&quot;: function(v)  { this.context.strokeStyle = v;   }
    });
    
    
    /**
     * @property    globalAlpha
     * アルファ指定
     */
    tm.graphics.Canvas.prototype.accessor(&quot;globalAlpha&quot;, {
<span id='tm-graphics-Canvas-property-width'>        &quot;get&quot;: function()   { return this.context.globalAlpha; },
</span>        &quot;set&quot;: function(v)  { this.context.globalAlpha = v;   }
    });
    
    
    /**
     * @property    globalCompositeOperation
     * ブレンド指定
     */
<span id='tm-graphics-Canvas-property-height'>    tm.graphics.Canvas.prototype.accessor(&quot;globalCompositeOperation&quot;, {
</span>        &quot;get&quot;: function()   { return this.context.globalCompositeOperation; },
        &quot;set&quot;: function(v)  { this.context.globalCompositeOperation = v;   }
    });

    /**
     * @property    shadowBlur
     * シャドウブラー
<span id='tm-graphics-Canvas-property-fillStyle'>     */
</span>    tm.graphics.Canvas.prototype.accessor(&quot;shadowBlur&quot;, {
        &quot;get&quot;: function()   { return this.context.shadowBlur; },
        &quot;set&quot;: function(v)  { this.context.shadowBlur = v;   }
    });
    

    /**
     * @property    shadowColor
     * シャドウブラーカラー
     */
<span id='tm-graphics-Canvas-property-strokeStyle'>    tm.graphics.Canvas.prototype.accessor(&quot;shadowColor&quot;, {
</span>        &quot;get&quot;: function()   { return this.context.shadowColor; },
        &quot;set&quot;: function(v)  { this.context.shadowColor = v;   }
    });
    

    /**
     * @property    shadowOffsetX
     * シャドウオフセット X 
     */
<span id='tm-graphics-Canvas-property-globalAlpha'>    tm.graphics.Canvas.prototype.accessor(&quot;shadowOffsetX&quot;, {
</span>        &quot;get&quot;: function()   { return this.context.shadowOffsetX; },
        &quot;set&quot;: function(v)  { this.context.shadowOffsetX = v;   }
    });
    

    /**
     * @property    shadowOffsetY
     * シャドウオフセット Y
     */
<span id='tm-graphics-Canvas-property-globalCompositeOperation'>    tm.graphics.Canvas.prototype.accessor(&quot;shadowOffsetY&quot;, {
</span>        &quot;get&quot;: function()   { return this.context.shadowOffsetY; },
        &quot;set&quot;: function(v)  { this.context.shadowOffsetY = v;   }
    });
    
    /**
     * @property    lineCap
     * ライン終端の描画方法
     */
    tm.graphics.Canvas.prototype.accessor(&quot;lineCap&quot;, {
<span id='tm-graphics-Canvas-property-shadowBlur'>        &quot;get&quot;: function()   { return this.context.lineCap; },
</span>        &quot;set&quot;: function(v)  { this.context.lineCap = v;   }
    });
    
    /**
     * @property    lineJoin
     * ラインつなぎ目の描画方法
     */
    tm.graphics.Canvas.prototype.accessor(&quot;lineJoin&quot;, {
<span id='tm-graphics-Canvas-property-shadowColor'>        &quot;get&quot;: function()   { return this.context.lineJoin; },
</span>        &quot;set&quot;: function(v)  { this.context.lineJoin = v;   }
    });
    
    /**
     * @property    miterLimit
     * マイターリミット
     */
    tm.graphics.Canvas.prototype.accessor(&quot;miterLimit&quot;, {
        &quot;get&quot;: function()   { return this.context.miterLimit; },
<span id='tm-graphics-Canvas-property-shadowOffsetX'>        &quot;set&quot;: function(v)  { this.context.miterLimit = v;   }
</span>    });
    
    /**
     * @property    lineWidth
     * ライン幅設定
     */
    tm.graphics.Canvas.prototype.accessor(&quot;lineWidth&quot;, {
        &quot;get&quot;: function()   { return this.context.lineWidth; },
<span id='tm-graphics-Canvas-property-shadowOffsetY'>        &quot;set&quot;: function(v)  { this.context.lineWidth = v;   }
</span>    });
    
    /**
     * @property    font
     * フォント
     */
    tm.graphics.Canvas.prototype.accessor(&quot;font&quot;, {
        &quot;get&quot;: function()   { return this.context.font; },
        &quot;set&quot;: function(v)  { this.context.font = v;   }
    });
    
    /**
     * @property    textAlign
<span id='tm-graphics-Canvas-property-lineCap'>     * テキストのアラインメント
</span>     */
    tm.graphics.Canvas.prototype.accessor(&quot;textAlign&quot;, {
        &quot;get&quot;: function()   { return this.context.textAlign; },
        &quot;set&quot;: function(v)  { this.context.textAlign = v;   }
    });
    
    /**
     * @property    textBaseline
<span id='tm-graphics-Canvas-property-lineJoin'>     * テキストのベースライン
</span>     */
    tm.graphics.Canvas.prototype.accessor(&quot;textBaseline&quot;, {
        &quot;get&quot;: function()   { return this.context.textBaseline; },
        &quot;set&quot;: function(v)  { this.context.textBaseline = v;   }
    });
    
    /**
     * @property    centerX
     * センターX
     */
<span id='tm-graphics-Canvas-property-miterLimit'>    tm.graphics.Canvas.prototype.getter(&quot;centerX&quot;, function() {
</span>        return this.canvas.width/2;
    });
    
    /**
     * @property    centerY
     * センターY
     */
    tm.graphics.Canvas.prototype.getter(&quot;centerY&quot;, function(){
        return this.canvas.height/2;
    });
<span id='tm-graphics-Canvas-property-lineWidth'>    
</span>})();

















</pre>
</body>
</html>
